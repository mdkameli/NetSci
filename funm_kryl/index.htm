<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Restart Code for the Evaluation of Matrix Functions</TITLE>
<META http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="description" content="Restart Code for the Evaluation of Matrix Functions using Krylov methods">
<meta name="keywords" content="matrix function, Krylov space, restart">
<meta name="revisit-after" content="7 days">
<meta http-equiv="content-script-type" content="text/javascript">
<meta name="author" content="Stefan G&uuml;ttel">
<meta name="robots" content="index, follow">



<STYLE type="text/css">
body  { font-size:11pt; font-family:Arial; line-height:16pt; margin:20px; margin-top:30px; color:#222222; }
div   { width:740px; max-width:740px; }
h1    { line-height:30pt; font-size:24pt; }
h2    { color:#0000FF; margin-top:50px; }
td,th { border:1px solid #000000; font-weight:normal;text-align:left; line-height:16pt;}
.head { background-color:#EEEEEE; font-weight:bold; }
tt    { font-size:11.7pt }
table { border:2px solid #000000; font-size:10pt; }
pre   { padding:10px; border:1px dotted #000000; font-size:12pt; }
i     { font-family:serif,times; font-size:12pt; padding-left:3px; padding-right:2px; }
</STYLE>
</HEAD>

<BODY>

<DIV>
<span style="color:#EE9933;font-size:30pt; font-weight:bold;">&gt; funm_kryl</span><img src="http://www.mathe.tu-freiberg.de/~guettels/cursor.gif" alt="&nbsp;"><br>
<H1>A Restart Code for the Evaluation<br>of Matrix Functions</H1>

<H2>About</H2>

This Matlab code computes restarted Krylov approximations to <i>f(A)b,</i> where <i>A</i> is a square, large and sparse matrix, <i>f</i> is a matrix function (such that <i>f(A)</i> is defined) and <i>b</i> is a vector.<br> 
A simple error bound (indicator in the non-Hermitian case) is provided and it is also possible to perform thick restarts or harmonic restarts. Simply call 

<pre>[f,out] = funm_kryl (A,b,param)</pre>

For the two implementations of this restarted Krylov method we refer to [1] and [5].

<br><br>This Matlab code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


<H2>Download</H2>

Download the latest version of <b>funm_kryl</b> here:

<pre style="background-color:#CCCCCC"><a href="http://www.mathe.tu-freiberg.de/~guettels/funm_kryl.zip"><b>Download funm_kryl</b></a> (about 20 kB, version 20090409)</pre>

To use <b>funm_kryl</b> extract the zip-archive on your computer and change to
the directory <tt>funm_kryl</tt> in Matlab. Run the example files to see how it works.



<H2>Input parameter</H2>

The structure <tt>param</tt> stores all relevant parameters for the algorithm to run. A default setup can be generated by 

<pre>param = param_init ()</pre>

The fields of <tt>param</tt> can now be modified as required. Note that not every parameter configuration makes sense, e.g., you cannot use <tt>param.H_full==false</tt> if <tt>param.function</tt> is not a structure of type <tt>parfrac</tt>. Therefore you should rerun

<pre>param = param_init (param)</pre>

which will check whether your settings are valid. If necessary, <tt>param_init</tt> returns a modified valid <tt>param</tt> structure.<br><br>


<table cellspacing="0" cellpadding="5">
<tr class="head">
<td width="130">Field of <tt>param</tt></td><td width="110">Type</td><td width="400">Values</td><td>Examples</td>
</tr>

<tr>
<th rowspan="2"><tt>function</tt></th>
<td>function handle</td>
<td>a handle to a Matlab function which takes a square matrix argument <i>H</i> and returns <i>f(H)</i></td>
<td><tt>param.function = @sinm;<br>
param.function = @myfunm;</tt></td>
</tr>
<tr>
<td>struct</td>
<td>a structure representing a partial fraction, see <a href="#parfrac"><tt>parfrac()</tt></a> for details</td>
<td><tt>param.function = 
    parfrac('expBA',16);</tt></td>
</tr>

<tr>
<th rowspan="2"><tt>V_full</tt></th>
<th rowspan="2">boolean</th>
<td><b>false:</b> (default) do not store the full Krylov basis</td>
<td>---</td>
</tr>
<tr>
<td><b>true:</b> keep the full Krylov basis in memory and return it in <tt>out.V_full</tt></td>
<td>---</td>
</tr>

<tr>
<th rowspan="2"><tt>H_full</tt></th>
<th rowspan="2">boolean</th>
<td><b>false:</b> use recursive scheme to compute updates of Arnoldi approximations (only available if <tt>param.function</tt> is a structure as returned by <tt>parfrac</tt>)</td>
<td>---</td>
</tr>
<tr>
<td><b>true:</b> (default) evaluate matrix function for full Hessenberg matrix <tt>H_full</tt> which grows in size with each restart cycle, <tt>out.H_full</tt> will be returned</td>
<td>---</td>
</tr>

<tr>
<td><tt>restart_length</tt></td>
<td>integer >= 1</td>
<td>if the dimension of the Krylov space exceeds <tt>param.restart_length</tt> the Krylov approximation will be updated and a new Krylov space is generated</td>
<td><tt>param.restart_length = 20;</tt></td>
</tr>

<tr>
<td><tt>max_restarts</tt></td>
<td>integer >= 1</td>
<td>number of cycles of the restarting algorithm (if the number is 1 no restart is done)</td>
<td><tt>param.max_restarts = 10;</tt></td>
</tr>

<tr>
<th rowspan="2"><tt>hermitian</tt></th>
<th rowspan="2">boolean</th>
<td><b>false:</b> (default) <i>A</i> is not Hermitian (the Arnoldi process is used)</td>
<td>---</td>
</tr>
<tr>
<td><b>true:</b> <i>A</i> is Hermitian (the Lanczos process is used)</td>
<td>---</td>
</tr>

<tr>
<td><tt>reorth_number</tt></td>
<td>0 (default), 1 or 2</td>
<td>number reorthonormalizations in the Gram-Schmidt orthonormalization (has no effect in the Hermitian case)</td>
<td>---</td>
</tr>


<tr>
<th rowspan="2"><tt>thick</tt></th>
<td>[]</td>
<td>(default) No thick-restarts are performed.</td>
<td>---</td>
</tr>
<tr>
<td>function handle</td>
<td>Thick-restarts are performed. This requires a
function that reorderes the Schur form <i>U*T*U'</i> of a Hessenberg matrix <i>H</i> with eigenvalues <i>D</i>
such that wanted eigenvalues occur in the upper left block of the reordered Schur matrix.
The wanted eigenvalues are returned in <tt>out.thick_replaced</tt> and the unwanted eigenvalues are
returned in <tt>out.thick_interpol</tt>.</td>
<td><tt>param.thick = @thick;</tt></td>
</tr>

<tr>
<td><tt>harmonic_target</tt></td>
<td>inf (default) or number</td>
<td>Target for harmonic Ritz extraction after each cycle. The value <tt>inf</tt>
corresponds to the standard Ritz extraction.</td>
<td>---</td>
</tr>



<tr>
<td><tt>exact</tt></td>
<td>vector</td>
<td>exact solution of <i>f(A)b</i>; if provided, <tt>out.err</tt> is a vector of the absolute error in the 2-norm of the Krylov approximation for each restart cycle
<td><tt>param.exact = expm(A)*b;</tt><br><tt>param.exact = [];</tt></td>
</tr>

<tr>
<td><tt>bound</tt></td>
<td>boolean</td>
<td>compute lower and upper error bounds (in non-Hermitan case these may be useful as error indicators)</td>
<td>---</td>
</tr>

<tr>
<td><tt>stopping_accuracy</tt></td>
<td>positive number</td>
<td>the restart iteration stops if the upper error bound or the absolute error of the Krylov approximation falls below this treshold (default accuracy is 1e-12)</td>
<td>---</td>
</tr>

<tr>
<td><tt>min_decay</tt></td>
<td>positive number</td>
<td>the restart iteration stops if the linear convergence rate of the upper error bound or the absolute error of the Krylov approximation is greater than this number (default linear decay rate is 0.95)</td>
<td>---</td>
</tr>

<tr>
<td><tt>waitbar</tt></td>
<td>boolean</td>
<td>show waitbar</td>
<td>---</td>
</tr>

</table>



<H2>Outputs</H2>


<pre>[f,out] = funm_kryl (A,b,param)
report(param.out)                 % show simple report</pre>


The restarted Krylov approxiation is returned in <tt>f</tt>.<br><br>

<tt>out</tt> is a structure with the following fields<br><br>


<table cellspacing="0" cellpadding="5">
<tr class="head">
<td width="130">Field</td><td width="110">Type</td><td width="400">Values</td>
</tr>

<tr>
<td><tt>out.update</tt></td>
<td>vector</td>
<td>norm of the updates of the Krylov approximations for each restart cycle</td>
</tr>

<tr>
<td><tt>out.err</tt></td>
<td>vector</td>
<td>absolute error of the Krylov approximations for each restart cycle (only available if <tt>param.exact</tt> is non-empty)</td>
</tr>

<tr>
<td><tt>out.time</tt></td>
<td>vector</td>
<td>computation time (i.e., Arnoldi/Lanczos decomposition + update of the approximation) for each restart cycle (<tt>sum(out.time)</tt> is the overall computation time)</td>
</tr>

<tr>
<td><tt>out.H_full</tt></td>
<td>matrix</td>
<td>block-bidiagonal upper Hessenberg matrix, only returned if <tt>param.H_full == 1</tt></td>
</tr>

<tr>
<td><tt>out.V_full</tt></td>
<td>matrix</td>
<td>the basis vectors of the full Krylov space, blockwise orthonormal, only returned if <tt>param.V_full == 1</tt></td>
</tr>

<tr>
<td><tt>out.bound_1, out.bound_2</tt></td>
<td>vector</td>
<td>lower and upper error estimators, only if <tt>param.bound == 1</tt> (requires eigenvalue calculation of a matrix of size (<tt>param.restart_length</tt> times <tt>param.restart_length</tt>) in each restart cycle).<br>For <i>A</i> Hermitian these bounds are based on Gauss-Radau and Gauss-Lobatto quadrature, respectively, and would be correct for <i>A</i>'s smallest and largest eigenvalue to be known. Since we use the smallest and largest Ritz values instead, these bounds improve for later cycles. These bounds are based on an extension of an idea given in [8] and [7].</td>
</tr>

<tr>
<td><tt>out.stop_condition</tt></td>
<td>string</td>
<td>string that tells which stop condition was satisfied at termination of the algorithm</td>
</tr>

<tr>
<td><tt>out.thick_replaced, out.thick_interpol</tt></td>
<td>cell array</td>
<td>if thick-restarts are used these arrays contain the wanted resp. unwanted eigenvalues
which occured during the restart method.</td>
</tr>
</table>

<br><br>
Please note: You may also call <tt>[f,out,<b>param_out</b>] = funm_kryl (A,b,param)</tt>. Then the output structure <tt>param_out</tt> is the same as the input structure <tt>param</tt> if all the parameter settings were valid. Otherwise <tt>param_out</tt> is the corrected version of the input-<tt>param</tt>-structure which was then actually used by the algorithm.


<a name="parfrac"></a>
<H2>Rational approximations</H2>

<pre>r = parfrac (type,degree,param1)
param.parfrac = r
x = 3; eval_parfrac(r,x)           % test evaluation at point x</pre>

The structure <tt>r</tt> is a representation of a partial fraction having <tt>degree</tt> poles. The following <tt>type</tt>s are implemented, further details may be found in [9]:
<br><br>


<table cellspacing="0" cellpadding="5">
<tr class="head">
<td width="130">Type</td><td width="110">Available degrees</td><td width="400">Meaning</td><td>param1</td>
</tr>

<tr>
<td><tt>expCF</tt></td>
<td>2,4,...,16(?)</td>
<td>quasi-best rational approximation to the exponential function on (-inf,0] via Caratheodory-Fejer</td>
<td>n.a.</td>
</tr>

<tr>
<td><tt>expWP</tt></td>
<td>1,2,...</td>
<td>rational approximation to the exponential function on (-inf,0] with poles on the Weidemann parabolic contour</td>
<td>n.a.</td>
</tr>

<tr>
<td><tt>expTW</tt></td>
<td>2,4,...</td>
<td>rational approximation to the exponential function on (-inf,0] with poles on the Talbot-Weidemann cotangent contour</td>
<td>n.a.</td>
</tr>

<tr>
<td><tt>expWH</tt></td>
<td>1,2,...</td>
<td>rational approximation to the exponential function on (-inf,0] with poles on the Weideman hyperbolic contour</td>
<td>n.a.</td>
</tr>

<tr>
<td><tt>expBA</tt></td>
<td>2,3,...,18</td>
<td>best rational approximation to the exponential function on (-inf,0] (Cody-Meinardus-Varga approximation), table lookup with coefficients given in [3], [4]</td>
<td>n.a.</td>
</tr>

<tr>
<td><tt>cfud</tt></td>
<td>1,2,...,8</td>
<td>best rational approximation to function defined by <tt>param1</tt> on the unit disk (CF-method)</td>
<td>handle to function analytic on unit disk, e.g., <tt>param1=@exp</tt>, <tt>param1=@cos</tt></td>
</tr>

<tr>
<td><tt>sqrtZ</tt></td>
<td>---</td>
<td>sqrtZ has been removed. Use <tt>sqrtinvZ</tt> to approximate x/sqrt(x).</td>
<td>---</td>
</tr>

<tr>
<td><tt>sqrtinvZ</tt></td>
<td>1,2,...,50</td>
<td>Zolotarovs relative best rational approximation to 1/sqrt(x) on the interval [1,param1]</td>
<td>right-end of approximation interval, e.g., <tt>param1=1e3</tt></td>
</tr>

<tr>
<td><tt>signZ</tt></td>
<td>1,2,...,50</td>
<td>Zolotarovs best rational approximation to sign(x) on the set [-param1,param1]\[-1,1]</td>
<td>end-point of approximation interval, e.g., <tt>param1=1e3</tt></td>
</tr>

<tr>
<td><tt>inv</tt></td>
<td>1</td>
<td>the function 1/z (solution of linear systems of equations)</td>
<td>n.a.</td>
</tr>

</table>

<H2>References</H2>

<tt>

[1] M. Afanasjew, M. Eiermann, O. G. Ernst, and S. G&uuml;ttel. Implementation of a Restarted Krylov
Subspace Method for the Evaluation of Matrix Functions. To appear, 2007.
<br><br>
[2] M. Afanasjew, M. Eiermann, O. G. Ernst, and S. G&uuml;ttel. On the steepest descent
method for matrix functions. In preparation, 2007.
<br><br>
[3] A. J. Carpenter, A. Ruttan, and R. S. Varga. Extended numerical computations
on the '1/9' conjecture in rational approximation theory. In P. R. Graves-Morris,
E. B. Saff, and R. S. Varga, editors, Rational Approximation and Interpolation,
Proceedings, Tampa, Florida 1983, number 1105 in Lecture Notes in Mathematics,
pages 383-411, Heidelberg, 1984. Springer-Verlag.
<br><br>
[4] W. J. Cody, G. Meinardus, and R. S. Varga. Chebyshev rational approximation to
exp(-x) in [0,+inf) and applications to heat-conduction problems. J. Approx. Theory,
2:50-65, 1969.
<br><br>
[5] M. Eiermann and O. G. Ernst. A restarted Krylov subspace method for the evaluation
of matrix functions. SIAM J. Numer. Anal., 44:2481-2504, 2006.
<br><br>
[6] M. Hochbruck and C. Lubich. On Krylov subspace approximations to the matrix
exponential operator. SIAM J. Numer. Anal., 34(5):1911-1925, October 1997.
<br><br>
[7] B. Philippe and R. B. Sidje. Transient solutions of Markov processes by Krylov
subspaces. Research Report, RR-1989, INRIA, 1995.
<br><br>
[8] Y. Saad. Analysis of some Krylov subspace approximations to the
operator. SIAM J. Numer. Anal., 29(1):209-228, February 1992.
<br><br>
[9] L. N. Trefethen, J. A. C. Weideman, and T. Schmelzer. Talbot quadratures and
rational approximations. BIT, 46:653-670, 2006.
</tt>


<br><br><br>

</DIV>

</BODY>
</HTML>

